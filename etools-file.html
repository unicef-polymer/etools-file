<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-toast/paper-toast.html">

<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="../paper-input/paper-input-error.html">

<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-menu/paper-menu.html">
<link rel="import" href="../paper-item/paper-item.html">

<link rel="import" href="style/etools-file-style.html">
<!--
`etools-file`

This element will allow you to select and prepare the files you are gonna upload.
The component doesn't upload the files, it just manages an array of them, which is reachable from the parent component.

### Styling

You can use defined variables to change element style.

Custom property | Description | Default
----------------|-------------|----------
`--etools-file-secondary-text-color` | Secondary text color | `rgba(255, 255, 255, 0.54)`
`--etools-file-main-btn-color` | Main buttons text color(upload and download buttons) | `#00acff`
`--etools-file-delete-btn-color` | Delete button text color | `#f1572a`
`--etools-file-single-file-wrapper` | Mixin applied to single file name wrapper | `{}`
`--etools-file-filename-container` | Mixin applied to the filename container | `{}`
`--etools-file-readonly-filename-container` | Mixin applied to the filename container(only if it's readonly) | `{}`
`--etools-file-actions-multiple` | Mixin applied to file action buttons container if multiple is `true` | `{}`
`--etools-file-actions-single` | Mixin applied to file action buttons container for single file selection | `{}`
`--etools-file-error` | Mixin applied to the error message element | `{}`
`--etools-file-type-underline-color` | File type underline color | `rgba(0, 0, 0, 0.12)`
`--etools-file-area-with-type-border-color` | File area with type underline color | `rgba(0, 0, 0, 0.12)`
`--etools-file-label` | File type underline color | `rgba(0, 0, 0, 0.12)`
`--etools-file-area-with-type` | File area with type mixin | `{}`
`--etools-file-upload-button-paper-btn` | Upload btn paper-button mixin | `{}`
`--etools-file-upload-button` | Upload button mixin | `{}`

@demo demo/index.html
-->

<dom-module id="etools-file">

  <template>
    <style include="etools-file-style">
      
    </style>

    <paper-input-container always-float-label disabled$="[[disabled]]" invalid$="[[invalid]]">

      <label id="element-label" hidden$="[[!_showLabel(label)]]" aria-hidden="true">[[label]]</label>

      <div class$="files-container [[_getMultipleClass(multiple)]]">
        <div class="files-wrapper" hidden$="[[!showFilesContainer]]">
          <template is="dom-repeat" items="[[files]]" as="file">

            <div class="file-area">

              <div class$="selected-file-container [[_getFileSelectedClass(file)]]">
                <iron-icon class="file-icon" icon="attachment"></iron-icon>
                <div class="file-name-wrapper">
                  <span class="file-name" title="[[file.file_name]]">[[file.file_name]]</span>
                </div>

                <template is="dom-if" if="[[_showReadonlyType(file.type, readonly)]]">
                  <div class="file-type-input-wrapper">
                    <paper-input class="file-type-input" label="[[fileTypesLabel]]" 
                      value="[[_getFileTypeStr(file.type)]]"
                      placeholder="&#8212;" readonly></paper-input>
                  </div>
                </template>
                <template is="dom-if" if="[[_showFileType(fileTypes.length, readonly)]]">
                  <!-- types dropdown -->
                  <paper-dropdown-menu class="type-dropdown" label="[[fileTypesLabel]]" placeholder="&#8212;" noink>
                    <paper-menu id$="typeDropdown_[[index]]" class="dropdown-content"
                                attr-for-selected="name"
                                on-iron-select="_typeChanged"
                                on-iron-deselect="_typeChanged"
                                selected={{file.type}}>
                      <template is="dom-repeat" items="[[fileTypes]]" as="fileType">
                        <paper-item name="[[fileType.id]]">[[fileType.name]]</paper-item>
                      </template>
                    </paper-menu>
                  </paper-dropdown-menu>
                </template>

              </div>
              <div class$="file-actions [[_getFileSelectedClass(file)]]">
                <!-- download btn if file was uploaded -->
                <paper-button class="download-button"
                              disabled$="[[!_showDownloadBtn(file)]]"
                              hidden$="[[!_showDownloadBtn(file)]]"
                              on-tap="_downloadFile"
                              title="Download">
                  <iron-icon icon="cloud-download"></iron-icon>
                  Download
                </paper-button>

                <paper-button class="change-button"
                              on-tap="_changeFile"
                              disabled$="[[readonly]]"
                              hidden$="[[readonly]]">
                  Change
                </paper-button>

                <paper-button class="delete-button"
                              on-tap="_deleteFile"
                              disabled$="[[readonly]]"
                              hidden$="[[readonly]]">
                  Delete
                </paper-button>
              </div>
            </div>
          </template>
        </div>

        <div class="upload-button-wrapper" hidden$="[[!_showUploadBtn(files.length, readonly)]]">
          <span>
            <paper-button class="upload-button"
                          on-tap="_openFileChooser"
                          title="[[uploadLabel]]"
                          disabled$="[[readonly]]">
            <iron-icon icon="file-upload"></iron-icon>
            [[uploadLabel]]
            </paper-button>
          </span>
        </div>
        <div class="no-file-and-readonly" hidden$="[[!_showNoFileAttachedMsg(files.length, readonly)]]">
          [[noFileAttachedMsg]]
        </div>
      </div>

      <template is="dom-if" if="[[invalid]]">
        <paper-input-error aria-live="assertive">[[errorMessage]]</paper-input-error>
      </template>

      <input
          hidden
          class="paper-input-input"
          type="file"
          id="fileInput"
          on-change="_fileSelected"
          multiple="[[multiple]]"
          accept="{{accept}}">

      <a id="downloader" hidden></a>

    </paper-input-container>

    <paper-toast id="fileAlreadySelectedToast" always-on-top></paper-toast>

  </template>

  <script>
    (function() {
      'use strict';

      Polymer({

        is: 'etools-file',

        properties: {
          label: {
            type: String,
            value: "File attachment"
          },
          files: {
            type: Object,
            value: function() {
              return [];
            },
            notify: true
          },
          multiple: {
            type: Boolean,
            value: false
          },
          disabled: {
            type: Boolean,
            value: false
          },
          accept: {
            type: String
          },
          uploadLabel: {
            type: String,
            value: 'Upload File'
          },
          readonly: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          invalid: {
            type: Boolean,
            value: function() {
              return false;
            }
          },
          errorMessage: {
            type: String,
            value: function() {
              return '';
            }
          },
          noFileAttachedMsg: {
            type: String,
            value: 'No file attached'
          },
          fileModel: {
            type: Object,
            value: null
          },
          useDeleteEvents: {
            type: Boolean,
            value: function() { 
              return false; 
            }
          },
          activateFileTypes: {
            type: Boolean,
            value: function() { 
              return false; 
            },
            reflectToAttribute: true
          },
          fileTypes: {
            type: Array,
            value: []
          },
          fileTypesLabel: {
            type: String,
            value: 'File Type'
          }
        },

        observers: [
          '_filesChange(files.*)'
        ],

        ready: function() {
          if (this.multiple && this.label === 'File attachment') {
            this.set('label', this.label + '(s)');
          }
          if (!Array.isArray(this.files)) {
            this.files = [];
          }
        },

        _showFileType: function(fileTypesLength, readonly) {
          return this.activateFileTypes && fileTypesLength > 0 && readonly === false;
        },

        _showReadonlyType: function(fileType, readonly) {
          return readonly && this.activateFileTypes;
        },

        _getFileTypeStr: function(fileType) {
          if (this.fileTypes.length > 0) {
            var type = this.fileTypes.filter(function(type) {
              return parseInt(type.id, 10) === parseInt(fileType, 10);
            })[0];
            if (type) {
              return type.name;
            }
            return null;
          }
          return null;
        },

        _showLabel: function(label) {
          return typeof label === 'string' && label !== '';
        },

        _showUploadBtn: function(filesLength, readonly) {
          if (!this.multiple && filesLength > 0) {
            return false;
          }

          if (filesLength === 0 && readonly === true) {
            return false;
          }

          return true;
        },

        _showNoFileAttachedMsg: function(filesLength, readonly) {
          return filesLength === 0 && readonly === true;
        },

        _showDownloadBtn: function(file) {
          if (file && typeof file.path === 'string' && file.path !== '') {
            return true;
          }
          return false;
        },

        _getFileSelectedClass: function(file) {
          if (!this._showDownloadBtn(file)) {
            return 'only-selected'
          }
          return '';
        },

        _openFileChooser: function() {
          var elem = this.$.fileInput;
          if (elem && document.createEvent) {
            var evt = document.createEvent('MouseEvents');
            evt.initEvent('click', true, false);
            elem.dispatchEvent(evt);
          }
        },

        _typeChanged: function(event) {
          // var typeVal = Polymer.dom(event).localTarget.selected;
          // console.log(event.model.index, typeVal);
          return;
        },

        _replaceFile: function(newFile) {
          if (this.changeFileIndex >= 0 && newFile) {
            this.$.fileInput.setAttribute('multiple', this.multiple);
            // this.set('disabled', false);
            if (this.files[this.changeFileIndex]) {
              if (this.multiple) {
                // check for already selected
                var fileAlreadySelected = this._checkFileAlreadySelected(newFile);
                if (fileAlreadySelected.length > 0) {
                  this._displayAlreadySelectedWarning(fileAlreadySelected);
                  this.changeFileIndex = -1;
                  // reset file input
                  this.$.fileInput.value = null;
                  return;
                }
              }
              var oldFile = this.files[this.changeFileIndex];
              var newFileObj = JSON.parse(JSON.stringify(oldFile));
              newFileObj.file_name = newFile.name;
              newFileObj.raw = newFile; 
              newFileObj.path = null;
              this.set('files.' + this.changeFileIndex, newFileObj);
            }
            this.changeFileIndex = -1;
            // reset file input
            this.$.fileInput.value = null;
            return true
          }
          this.changeFileIndex = -1;
          return false;
        },

        _addMultipleFiles: function(files) {
          var filesAlreadySelected = [];
          for (var i = 0; i < files.length; i++) {
            var fileAlreadySelected = this._checkFileAlreadySelected(files[i]);
            if (fileAlreadySelected.length === 0) {
              
              var fileObj = this._getFileModel(); 
              fileObj.file_name = files[i].name;
              fileObj.raw = files[i];
              
              this.push('files', fileObj);
            } else {
              filesAlreadySelected.push(fileAlreadySelected[0]);
            }
          }
          if (filesAlreadySelected.length > 0) {
            this._displayAlreadySelectedWarning(filesAlreadySelected);
            filesAlreadySelected = [];
          }
        },

        _checkFileAlreadySelected: function(file) {
          var fileAlreadySelected = this.files.filter(function(f) {
            return f.file_name === file.name && (f.path === '' || f.path === null || typeof f.path === 'undefined');
          });
          return fileAlreadySelected;
        },

        _displayAlreadySelectedWarning: function(filesAlreadySelected) {
          // show a warning with the already selected files
          var toastWarningMessage = '<p><strong>The following file are already selected:</strong><p>';
          filesAlreadySelected.forEach(function(alreadySelectedFile) {
            toastWarningMessage += '<p>' + alreadySelectedFile.file_name + '</p>';
          });
          Polymer.dom(this.$.fileAlreadySelectedToast).innerHTML = toastWarningMessage;
          this.$.fileAlreadySelectedToast.open();
        },

        _getFileModel: function() {
          if (this.fileModel) {
            return JSON.parse(JSON.stringify(this.fileModel));
          } else {
            return {
              id: null,
              file_name: null,
              path: null,
              raw: null
            };
          }
        },

        _addSingleFile: function(file) {
          if (file) {
            var fileObj = this._getFileModel(); 
            fileObj.file_name = file.name;
            fileObj.raw = file;
            
            if (this.files.length === 0) {
              // add file
              this.push('files', fileObj);
            } else {
              // replace/change file
              this.set('files.0', fileObj);
            }
          }
        },

        _fileSelected: function(e) {
          var files = e.target.files;
          // replace file if case
          if (this._replaceFile(files[0]) === true) {
            return;
          }

          // new files selected
          if (this.multiple) {
            this._addMultipleFiles(files);
          } else {
            // single file upload
            var file = e.target.files[0];
            this._addSingleFile(file);
          }
          // reset file input
          this.$.fileInput.value = null;
        },

        _changeFile: function(e) {
          if (e.model.index >= 0) {
            this.changeFileIndex = e.model.index;
            // this.set('disabled', true);
            this.$.fileInput.removeAttribute('multiple');
            this._openFileChooser();
          }
        },

        _deleteFile: function(e) {
          if (!this.multiple) {
            if (this.files.length > 0) {
              if (this.useDeleteEvents) {
                this.fire('delete-file', {file: this.files[0], index: 0});
              } else {
                this.set('files', []);
              }
              this.$.fileInput.value = null;
            }
          } else {
            if (typeof e.model.index === 'number' && e.model.index >= 0) {
              if (this.useDeleteEvents) {
                this.fire('delete-file', {file: this.files[e.model.index], index: e.model.index});
              } else {
                this.splice('files', e.model.index, 1);
              }
            }
          }
        },

        _filesChange: function() {
          if (this.files instanceof Array && this.files.length > 0) {
            this.set('showFilesContainer', true);
          } else {
            this.set('showFilesContainer', false);
          }

          if (!this.multiple) {
            if (this.files instanceof Array && this.files.length > 1) {
              this.set('files', [this.files[0]]);
            }
          }
        },

        _downloadFile: function(e) {
          if (this.files.length > 0) {
            var file = this.files[0];
            if (this.multiple && this.files[e.model.index]) {
              file = this.files[e.model.index];
            }
            if (typeof file !== 'undefined' && file.path !== '') {
              var a = this.$.downloader;
              a.href = file.path;
              a.download = file.file_name;
              a.click();
              window.URL.revokeObjectURL(file.path);
            }
          }
        },

        _getMultipleClass: function(multiple) {
          if (multiple) {
            return 'multiple';
          }
          return '';
        },


      });
    })();
  </script>
</dom-module>
